@startuml Media Management - Sequence Diagrams

!pragma teoz true

' ================================================================================
' Upload Media Flow
' ================================================================================

@startuml Upload Media Flow
title Upload Media Flow

actor User
participant "API Controller" as API
participant "MediatR" as MediatR
participant "UploadMediaHandler" as Handler
participant "IMediaStorageService" as Storage
participant "Media Aggregate" as Media
participant "IMediaRepository" as Repository
participant "EventBus" as EventBus
queue "Azure Blob Storage" as Blob

User -> API: POST /api/media/upload\n(file, metadata)
activate API

API -> MediatR: Send(UploadMediaCommand)
activate MediatR

MediatR -> Handler: Handle(command)
activate Handler

Handler -> Storage: UploadAsync(fileStream, fileName, contentType, accountId)
activate Storage

Storage -> Blob: Upload file to container
activate Blob
Blob --> Storage: Storage location
deactivate Blob

Storage --> Handler: storageLocation
deactivate Storage

Handler -> Media: Create(fileName, fileType, fileSize, storageLocation, uploadedBy, accountId)
activate Media

Media -> Media: Validate invariants
Media -> Media: AddDomainEvent(MediaUploadedDomainEvent)

Media --> Handler: Media entity
deactivate Media

Handler -> Repository: AddAsync(media)
activate Repository
Repository --> Handler: void
deactivate Repository

Handler -> Repository: SaveChangesAsync()
activate Repository

Repository -> Repository: Save to database
Repository -> EventBus: Publish(MediaUploadedDomainEvent)
activate EventBus
EventBus --> Repository: void
deactivate EventBus

Repository --> Handler: void
deactivate Repository

Handler --> MediatR: UploadMediaResponse\n(mediaId, storageLocation, uploadedAt)
deactivate Handler

MediatR --> API: response
deactivate MediatR

API --> User: 201 Created\n(media details)
deactivate API

note right of EventBus
  Event triggers:
  - Media processing pipeline
  - Notification services
  - Analytics tracking
end note

@enduml

' ================================================================================
' Process Media Flow
' ================================================================================

@startuml Process Media Flow
title Process Media - Resize/Transcode Flow

participant "Event Consumer" as Consumer
participant "MediatR" as MediatR
participant "ProcessMediaHandler" as Handler
participant "IMediaStorageService" as Storage
participant "IMediaProcessingService" as Processing
participant "Media Aggregate" as Media
participant "IMediaRepository" as Repository
participant "EventBus" as EventBus
queue "Azure Blob Storage" as Blob

Consumer -> Consumer: Receive MediaUploadedEvent
activate Consumer

Consumer -> MediatR: Send(ProcessMediaCommand)
activate MediatR

MediatR -> Handler: Handle(command)
activate Handler

Handler -> Repository: GetByIdAsync(mediaId)
activate Repository
Repository --> Handler: Media entity
deactivate Repository

Handler -> Storage: DownloadAsync(storageLocation)
activate Storage

Storage -> Blob: Download file
activate Blob
Blob --> Storage: file stream
deactivate Blob

Storage --> Handler: mediaStream
deactivate Storage

Handler -> Processing: ProcessImageAsync(stream, processingType, outputFormats)
activate Processing
note right
  For images: resize, optimize
  For videos: transcode, generate thumbnails
  For audio: transcode, normalize
end note

Processing -> Processing: Generate variants\n(thumbnails, sizes, formats)

Processing --> Handler: ProcessingResult\n(processedFiles, duration)
deactivate Processing

loop For each processed file
  Handler -> Storage: UploadAsync(processedStream, fileName)
  activate Storage
  Storage -> Blob: Upload processed variant
  activate Blob
  Blob --> Storage: variant location
  deactivate Blob
  Storage --> Handler: storageLocation
  deactivate Storage

  Handler -> Media: Add ProcessedMediaVersion
  activate Media
  Media --> Handler: void
  deactivate Media
end

Handler -> Media: MarkAsProcessed(processingType, outputFormats, duration, width, height, duration)
activate Media

Media -> Media: Update processing status
Media -> Media: AddDomainEvent(MediaProcessedDomainEvent)

Media --> Handler: void
deactivate Media

Handler -> Repository: UpdateAsync(media)
activate Repository
Repository --> Handler: void
deactivate Repository

Handler -> Repository: SaveChangesAsync()
activate Repository

Repository -> Repository: Save to database
Repository -> EventBus: Publish(MediaProcessedDomainEvent)
activate EventBus
EventBus --> Repository: void
deactivate EventBus

Repository --> Handler: void
deactivate Repository

Handler --> MediatR: ProcessMediaResponse\n(success, generatedVersions, duration)
deactivate Handler

MediatR --> Consumer: response
deactivate MediatR

Consumer --> Consumer: Processing complete
deactivate Consumer

@enduml

' ================================================================================
' Tag Media Flow
' ================================================================================

@startuml Tag Media Flow
title Tag Media Flow

actor User
participant "API Controller" as API
participant "MediatR" as MediatR
participant "TagMediaHandler" as Handler
participant "Media Aggregate" as Media
participant "IMediaRepository" as Repository
participant "EventBus" as EventBus

User -> API: POST /api/media/{id}/tags\n(tags)
activate API

API -> MediatR: Send(TagMediaCommand)
activate MediatR

MediatR -> Handler: Handle(command)
activate Handler

Handler -> Repository: GetByIdAsync(mediaId)
activate Repository
Repository --> Handler: Media entity
deactivate Repository

Handler -> Media: AddTags(tags, taggedBy)
activate Media

Media -> Media: Validate tags
Media -> Media: Create MediaTag entities
Media -> Media: AddDomainEvent(MediaTaggedDomainEvent)

Media --> Handler: void
deactivate Media

Handler -> Repository: UpdateAsync(media)
activate Repository
Repository --> Handler: void
deactivate Repository

Handler -> Repository: SaveChangesAsync()
activate Repository

Repository -> Repository: Save to database
Repository -> EventBus: Publish(MediaTaggedDomainEvent)
activate EventBus

EventBus -> EventBus: Notify search index
EventBus -> EventBus: Update analytics

EventBus --> Repository: void
deactivate EventBus

Repository --> Handler: void
deactivate Repository

Handler --> MediatR: Unit
deactivate Handler

MediatR --> API: success
deactivate MediatR

API --> User: 200 OK
deactivate API

@enduml

' ================================================================================
' Download Media Flow
' ================================================================================

@startuml Download Media Flow
title Download Media Flow

actor User
participant "API Controller" as API
participant "MediatR" as MediatR
participant "GetDownloadUrlHandler" as Handler
participant "IMediaRepository" as Repository
participant "Media Aggregate" as Media
participant "IMediaStorageService" as Storage
participant "EventBus" as EventBus
queue "Azure Blob Storage" as Blob

User -> API: GET /api/media/{id}/download
activate API

API -> MediatR: Send(GetMediaDownloadUrlQuery)
activate MediatR

MediatR -> Handler: Handle(query)
activate Handler

Handler -> Repository: GetByIdAsync(mediaId)
activate Repository
Repository --> Handler: Media entity
deactivate Repository

Handler -> Handler: Validate permissions
Handler -> Handler: Check account access

Handler -> Storage: GetDownloadUrlAsync(storageLocation, expirationTime)
activate Storage

Storage -> Blob: Generate SAS token
activate Blob
Blob --> Storage: Signed URL with expiration
deactivate Blob

Storage --> Handler: downloadUrl
deactivate Storage

Handler -> Media: IncrementDownloadCount(downloadedBy)
activate Media

Media -> Media: Increment counter
Media -> Media: AddDomainEvent(MediaDownloadedDomainEvent)

Media --> Handler: void
deactivate Media

Handler -> Repository: UpdateAsync(media)
activate Repository
Repository --> Handler: void
deactivate Repository

Handler -> Repository: SaveChangesAsync()
activate Repository

Repository -> EventBus: Publish(MediaDownloadedDomainEvent)
activate EventBus

EventBus -> EventBus: Track download analytics
EventBus -> EventBus: Update usage metrics

EventBus --> Repository: void
deactivate EventBus

Repository --> Handler: void
deactivate Repository

Handler --> MediatR: MediaDownloadUrlDto\n(mediaId, downloadUrl, expiresAt)
deactivate Handler

MediatR --> API: response
deactivate MediatR

API --> User: 200 OK\n(download URL, expiration)
deactivate API

User -> Blob: GET downloadUrl\n(direct download)
activate Blob
Blob --> User: File content
deactivate Blob

note right of Blob
  SAS token provides:
  - Time-limited access
  - No authentication required
  - Direct CDN download
  - Bandwidth optimization
end note

@enduml

' ================================================================================
' Delete Media Flow
' ================================================================================

@startuml Delete Media Flow
title Delete Media Flow

actor User
participant "API Controller" as API
participant "MediatR" as MediatR
participant "DeleteMediaHandler" as Handler
participant "IMediaRepository" as Repository
participant "Media Aggregate" as Media
participant "IMediaStorageService" as Storage
participant "EventBus" as EventBus
queue "Azure Blob Storage" as Blob

User -> API: DELETE /api/media/{id}?type=soft
activate API

API -> MediatR: Send(DeleteMediaCommand)
activate MediatR

MediatR -> Handler: Handle(command)
activate Handler

Handler -> Repository: GetByIdAsync(mediaId)
activate Repository
Repository --> Handler: Media entity
deactivate Repository

Handler -> Handler: Validate permissions
Handler -> Handler: Check dependencies

Handler -> Media: Delete(deletedBy, deletionType)
activate Media

Media -> Media: Mark as deleted\nSet DeletedAt timestamp
Media -> Media: AddDomainEvent(MediaDeletedDomainEvent)

Media --> Handler: void
deactivate Media

alt Deletion Type is HardDelete

  Handler -> Storage: DeleteAsync(storageLocation)
  activate Storage

  Storage -> Blob: Delete main file
  activate Blob
  Blob --> Storage: void
  deactivate Blob

  loop For each processed version
    Storage -> Blob: Delete processed variant
    activate Blob
    Blob --> Storage: void
    deactivate Blob
  end

  Storage --> Handler: void
  deactivate Storage

  Handler -> Repository: DeleteAsync(media)
  activate Repository
  Repository --> Handler: void
  deactivate Repository

else Deletion Type is SoftDelete

  Handler -> Repository: UpdateAsync(media)
  activate Repository
  Repository --> Handler: void
  deactivate Repository

end

Handler -> Repository: SaveChangesAsync()
activate Repository

Repository -> EventBus: Publish(MediaDeletedDomainEvent)
activate EventBus

EventBus -> EventBus: Update search index
EventBus -> EventBus: Cleanup references
EventBus -> EventBus: Archive analytics

EventBus --> Repository: void
deactivate EventBus

Repository --> Handler: void
deactivate Repository

Handler --> MediatR: Unit
deactivate Handler

MediatR --> API: success
deactivate MediatR

API --> User: 204 No Content
deactivate API

note right of Media
  **Soft Delete**
  - Mark IsDeleted = true
  - Preserve data
  - Enable recovery

  **Hard Delete**
  - Remove from storage
  - Delete all variants
  - Permanent removal
end note

@enduml

@enduml
