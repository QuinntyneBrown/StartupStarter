@startuml API Management Sequence Diagrams

!define FRONTEND_COLOR #E1F5FE
!define API_COLOR #FFF9C4
!define SERVICE_COLOR #F3E5F5
!define REPOSITORY_COLOR #C8E6C9
!define EVENT_COLOR #FFCCBC
!define DB_COLOR #CFD8DC

' ====================================================================
' Create API Key Flow
' ====================================================================
@startuml Create API Key
title Create API Key - MediatR Command Flow with Key Generation and Hashing

actor "Developer" as Developer FRONTEND_COLOR
participant "Angular UI" as UI FRONTEND_COLOR
participant "API Gateway" as Gateway API_COLOR
participant "API Key Controller" as Controller API_COLOR
participant "MediatR" as Mediator SERVICE_COLOR
participant "CreateApiKeyHandler" as Handler SERVICE_COLOR
participant "ISecurityService" as SecurityService SERVICE_COLOR
participant "IApiKeyRepository" as Repo REPOSITORY_COLOR
participant "DbContext" as DB DB_COLOR
participant "IDomainEventDispatcher" as EventDispatcher EVENT_COLOR
participant "Azure Service Bus" as ServiceBus EVENT_COLOR
participant "SignalR Hub" as SignalR EVENT_COLOR

Developer -> UI : Create New API Key
activate UI

UI -> Gateway : POST /api/apikeys\n{keyName, permissions, expiresAt}
activate Gateway
note right: JWT Bearer Token\nfor authentication

Gateway -> Controller : Route Request
activate Controller

Controller -> Mediator : Send(CreateApiKeyCommand)
activate Mediator

Mediator -> Handler : Handle(CreateApiKeyCommand)
activate Handler

Handler -> Handler : Validate Command
note right: FluentValidation\nKeyName required\nPermissions valid\nExpiresAt future date

Handler -> SecurityService : GenerateApiKey()
activate SecurityService
SecurityService --> Handler : plainTextKey\n(e.g., "sk_live_abc123...")
deactivate SecurityService
note right: Cryptographically secure\n32-byte random key\nBase64 encoded

Handler -> SecurityService : HashApiKey(plainTextKey)
activate SecurityService
SecurityService --> Handler : hashedKey
deactivate SecurityService
note right: SHA-256 hash with salt\nNever store plain text

Handler -> Handler : ApiKey.Create()
note right: Domain entity\nraises ApiKeyCreatedDomainEvent

Handler -> Repo : AddAsync(apiKey)
activate Repo
Repo -> DB : INSERT ApiKey\nSET HashedKey = {hashedKey}
activate DB
DB --> Repo : Success
deactivate DB
Repo --> Handler : Success
deactivate Repo

Handler -> Repo : SaveChangesAsync()
activate Repo
Repo -> DB : COMMIT Transaction
activate DB
DB --> Repo : Success
deactivate DB
Repo --> Handler : Success
deactivate Repo

Handler -> EventDispatcher : DispatchAsync(domainEvents)
activate EventDispatcher
note right: Publish domain events\nafter successful save

par Parallel Event Processing
    EventDispatcher -> ServiceBus : Publish\nApiKeyCreatedEvent
    activate ServiceBus
    note right: Integration event for:\n- Audit logging\n- Analytics\n- Third-party integrations
    ServiceBus --> EventDispatcher : Acknowledged
    deactivate ServiceBus
and
    EventDispatcher -> SignalR : Notify Real-time\nApiKeyCreated
    activate SignalR
    note right: Real-time notification\nto connected clients
    SignalR --> EventDispatcher : Acknowledged
    deactivate SignalR
end

EventDispatcher --> Handler : Complete
deactivate EventDispatcher

Handler --> Mediator : CreateApiKeyResponse\n{apiKeyId, plainTextKey, createdAt}
deactivate Handler
note right: Plain text key returned\nONLY ONCE - never stored

Mediator --> Controller : Response
deactivate Mediator

Controller --> Gateway : 201 Created\n{apiKeyId, apiKey (plain), expiresAt}
deactivate Controller

Gateway --> UI : Response
deactivate Gateway

UI --> Developer : API Key Created!\n[Display key with warning:\n"Save this key - it won't be shown again"]
deactivate UI

@enduml

' ====================================================================
' Validate API Key & Log Request Flow
' ====================================================================
@startuml Validate API Key and Log Request
title Validate API Key & Log Request - Authentication and Request Logging

actor "API Client" as Client FRONTEND_COLOR
participant "API Gateway" as Gateway API_COLOR
participant "Auth Middleware" as AuthMiddleware API_COLOR
participant "Request Logger" as RequestLogger API_COLOR
participant "MediatR" as Mediator SERVICE_COLOR
participant "ValidateApiKeyHandler" as ValidateHandler SERVICE_COLOR
participant "LogApiRequestHandler" as LogHandler SERVICE_COLOR
participant "ISecurityService" as SecurityService SERVICE_COLOR
participant "IApiKeyRepository" as ApiKeyRepo REPOSITORY_COLOR
participant "IApiRequestRepository" as RequestRepo REPOSITORY_COLOR
participant "DbContext" as DB DB_COLOR
participant "IDomainEventDispatcher" as EventDispatcher EVENT_COLOR
participant "Resource Controller" as ResourceController API_COLOR

Client -> Gateway : GET /api/resource\nHeader: X-API-Key: sk_live_abc123...
activate Gateway

Gateway -> AuthMiddleware : Authenticate Request
activate AuthMiddleware

AuthMiddleware -> AuthMiddleware : Extract API Key\nfrom Header
note right: Support multiple auth methods:\n- Header: X-API-Key\n- Query: ?api_key=\n- Bearer token

AuthMiddleware -> Mediator : Send(ValidateApiKeyQuery)
activate Mediator

Mediator -> ValidateHandler : Handle(ValidateApiKeyQuery)
activate ValidateHandler

ValidateHandler -> SecurityService : HashApiKey(plainTextKey)
activate SecurityService
SecurityService --> ValidateHandler : hashedKey
deactivate SecurityService
note right: Hash provided key\nto compare with stored hash

ValidateHandler -> ApiKeyRepo : GetByHashedKeyAsync(hashedKey)
activate ApiKeyRepo
ApiKeyRepo -> DB : SELECT ApiKey\nWHERE HashedKey = {hashedKey}
activate DB
DB --> ApiKeyRepo : ApiKey
deactivate DB
ApiKeyRepo --> ValidateHandler : ApiKey
deactivate ApiKeyRepo

ValidateHandler -> ValidateHandler : apiKey.IsValid()
note right: Check:\n- Status = Active\n- Not expired\n- Account active

alt API Key Invalid
    ValidateHandler --> Mediator : ApiKeyValidationResult\n{isValid: false, invalidReason}
    Mediator --> AuthMiddleware : Invalid Key
    AuthMiddleware --> Gateway : 401 Unauthorized\n{error: "Invalid API key"}
    Gateway --> Client : 401 Unauthorized
else API Key Valid
    ValidateHandler --> Mediator : ApiKeyValidationResult\n{isValid: true, apiKeyId, accountId, permissions}
    deactivate ValidateHandler
    Mediator --> AuthMiddleware : Valid Key
    deactivate Mediator

    AuthMiddleware -> RequestLogger : Log API Request
    activate RequestLogger

    RequestLogger -> Mediator : Send(LogApiRequestCommand)
    activate Mediator

    Mediator -> LogHandler : Handle(LogApiRequestCommand)
    activate LogHandler

    LogHandler -> LogHandler : ApiRequest.Create()
    note right: Capture request metadata:\n- Endpoint, Method\n- IP Address, User Agent\n- Timestamp

    LogHandler -> RequestRepo : AddAsync(apiRequest)
    activate RequestRepo
    RequestRepo -> DB : INSERT ApiRequest
    activate DB
    DB --> RequestRepo : Success
    deactivate DB
    RequestRepo --> LogHandler : Success
    deactivate RequestRepo

    LogHandler -> RequestRepo : SaveChangesAsync()
    activate RequestRepo
    RequestRepo -> DB : COMMIT
    activate DB
    DB --> RequestRepo : Success
    deactivate DB
    RequestRepo --> LogHandler : Success
    deactivate RequestRepo

    LogHandler -> EventDispatcher : DispatchAsync(domainEvents)
    activate EventDispatcher
    EventDispatcher -> ServiceBus : Publish\nApiRequestReceivedEvent
    activate ServiceBus
    note right: For analytics and monitoring
    ServiceBus --> EventDispatcher : Acknowledged
    deactivate ServiceBus
    EventDispatcher --> LogHandler : Complete
    deactivate EventDispatcher

    LogHandler --> Mediator : LogApiRequestResponse\n{requestId, timestamp}
    deactivate LogHandler
    Mediator --> RequestLogger : Success
    deactivate Mediator
    RequestLogger --> AuthMiddleware : Request Logged
    deactivate RequestLogger

    AuthMiddleware -> AuthMiddleware : Set Context\n(ApiKeyId, AccountId, Permissions)
    note right: Add to HttpContext\nfor downstream use

    AuthMiddleware --> Gateway : Authenticated
    deactivate AuthMiddleware

    Gateway -> ResourceController : Route to Controller
    activate ResourceController

    ResourceController -> ResourceController : Check Permissions
    note right: Verify API key has\nrequired permission

    alt Missing Permission
        ResourceController --> Gateway : 403 Forbidden
        Gateway --> Client : 403 Forbidden
    else Has Permission
        ResourceController -> ResourceController : Process Request
        ResourceController --> Gateway : 200 OK\n{resource data}
        Gateway --> Client : 200 OK\n{resource data}
    end

    deactivate ResourceController
end

deactivate Gateway

@enduml

' ====================================================================
' Rate Limiting Flow
' ====================================================================
@startuml Rate Limiting Flow
title Rate Limiting Flow - Rate Limit Checking and Enforcement

actor "API Client" as Client FRONTEND_COLOR
participant "API Gateway" as Gateway API_COLOR
participant "Rate Limit Middleware" as RateLimitMiddleware API_COLOR
participant "Redis Cache" as Redis EVENT_COLOR
participant "MediatR" as Mediator SERVICE_COLOR
participant "RecordRateLimitHandler" as Handler SERVICE_COLOR
participant "IApiRequestRepository" as RequestRepo REPOSITORY_COLOR
participant "DbContext" as DB DB_COLOR
participant "IDomainEventDispatcher" as EventDispatcher EVENT_COLOR
participant "Azure Service Bus" as ServiceBus EVENT_COLOR
participant "Resource Controller" as ResourceController API_COLOR

Client -> Gateway : API Request\nX-API-Key: sk_live_abc123...
activate Gateway

Gateway -> RateLimitMiddleware : Check Rate Limit
activate RateLimitMiddleware

RateLimitMiddleware -> RateLimitMiddleware : Get Account Context
note right: From previous\nauth middleware

RateLimitMiddleware -> RateLimitMiddleware : Determine Rate Limit Tier
note right: Based on account subscription:\n- Free: 100/hour\n- Basic: 1,000/hour\n- Pro: 10,000/hour\n- Enterprise: 100,000/hour\n- Unlimited: No limit

RateLimitMiddleware -> RateLimitMiddleware : Build Cache Key
note right: Pattern:\nratelimit:{accountId}:{hour}

RateLimitMiddleware -> Redis : GET rate limit counter
activate Redis
Redis --> RateLimitMiddleware : currentCount
deactivate Redis

RateLimitMiddleware -> RateLimitMiddleware : Check if limit exceeded
note right: Compare currentCount\nwith tier limit

alt Rate Limit Exceeded
    RateLimitMiddleware -> Redis : Increment counter
    activate Redis
    Redis --> RateLimitMiddleware : newCount
    deactivate Redis

    RateLimitMiddleware -> Mediator : Send(RecordRateLimitCommand)
    activate Mediator

    Mediator -> Handler : Handle(RecordRateLimitCommand)
    activate Handler

    Handler -> RequestRepo : GetByIdAsync(requestId)
    activate RequestRepo
    RequestRepo -> DB : SELECT ApiRequest
    activate DB
    DB --> RequestRepo : ApiRequest
    deactivate DB
    RequestRepo --> Handler : ApiRequest
    deactivate RequestRepo

    Handler -> Handler : apiRequest.MarkAsRateLimited(tier)
    note right: Sets WasRateLimited = true\nResponseStatus = 429\nRaises ApiRequestRateLimitedDomainEvent

    Handler -> RequestRepo : UpdateAsync(apiRequest)
    activate RequestRepo
    RequestRepo -> DB : UPDATE ApiRequest\nSET WasRateLimited = true
    activate DB
    DB --> RequestRepo : Success
    deactivate DB
    RequestRepo --> Handler : Success
    deactivate RequestRepo

    Handler -> RequestRepo : SaveChangesAsync()
    activate RequestRepo
    RequestRepo -> DB : COMMIT
    activate DB
    DB --> RequestRepo : Success
    deactivate DB
    RequestRepo --> Handler : Success
    deactivate RequestRepo

    Handler -> EventDispatcher : DispatchAsync(domainEvents)
    activate EventDispatcher

    EventDispatcher -> ServiceBus : Publish\nApiRequestRateLimitedEvent
    activate ServiceBus
    note right: For alerting and monitoring:\n- Email notification\n- Dashboard alert\n- Upgrade prompts
    ServiceBus --> EventDispatcher : Acknowledged
    deactivate ServiceBus

    EventDispatcher --> Handler : Complete
    deactivate EventDispatcher

    Handler --> Mediator : Success
    deactivate Handler
    Mediator --> RateLimitMiddleware : Complete
    deactivate Mediator

    RateLimitMiddleware -> RateLimitMiddleware : Calculate Reset Time
    note right: End of current hour window

    RateLimitMiddleware --> Gateway : 429 Too Many Requests\nHeaders:\n- X-RateLimit-Limit: {limit}\n- X-RateLimit-Remaining: 0\n- X-RateLimit-Reset: {resetTime}\n- Retry-After: {seconds}
    deactivate RateLimitMiddleware

    Gateway --> Client : 429 Too Many Requests\n{error message, retry info}
    deactivate Gateway

else Within Rate Limit
    RateLimitMiddleware -> Redis : INCR counter\nSET EXPIRE 1 hour
    activate Redis
    Redis --> RateLimitMiddleware : newCount
    deactivate Redis

    RateLimitMiddleware -> RateLimitMiddleware : Calculate Remaining
    note right: remaining = limit - newCount

    RateLimitMiddleware -> RateLimitMiddleware : Add Rate Limit Headers
    note right: X-RateLimit-Limit: {limit}\nX-RateLimit-Remaining: {remaining}\nX-RateLimit-Reset: {resetTime}

    RateLimitMiddleware --> Gateway : Continue to Controller
    deactivate RateLimitMiddleware

    Gateway -> ResourceController : Process Request
    activate ResourceController
    ResourceController -> ResourceController : Handle Request
    ResourceController --> Gateway : 200 OK\n{response data}
    deactivate ResourceController

    Gateway --> Client : 200 OK\nHeaders:\n- X-RateLimit-Limit: {limit}\n- X-RateLimit-Remaining: {remaining}\n- X-RateLimit-Reset: {resetTime}
    deactivate Gateway
end

@enduml

' ====================================================================
' Register Webhook Flow
' ====================================================================
@startuml Register Webhook
title Register Webhook - Webhook Registration with Validation

actor "Developer" as Developer FRONTEND_COLOR
participant "Angular UI" as UI FRONTEND_COLOR
participant "API Gateway" as Gateway API_COLOR
participant "Webhook Controller" as Controller API_COLOR
participant "MediatR" as Mediator SERVICE_COLOR
participant "RegisterWebhookHandler" as Handler SERVICE_COLOR
participant "IWebhookValidationService" as ValidationService SERVICE_COLOR
participant "HttpClient" as HttpClient SERVICE_COLOR
participant "IWebhookRepository" as Repo REPOSITORY_COLOR
participant "DbContext" as DB DB_COLOR
participant "IDomainEventDispatcher" as EventDispatcher EVENT_COLOR
participant "Azure Service Bus" as ServiceBus EVENT_COLOR

Developer -> UI : Register Webhook
activate UI

UI -> Gateway : POST /api/webhooks\n{url, events: ["content.created", "content.published"]}
activate Gateway
note right: JWT Bearer Token\nfor authentication

Gateway -> Controller : Route Request
activate Controller

Controller -> Mediator : Send(RegisterWebhookCommand)
activate Mediator

Mediator -> Handler : Handle(RegisterWebhookCommand)
activate Handler

Handler -> Handler : Validate Command
note right: FluentValidation\n- URL required & valid format\n- URL must be HTTPS\n- Events list not empty\n- Event types valid

Handler -> ValidationService : ValidateWebhookUrl(url)
activate ValidationService

ValidationService -> ValidationService : Check URL Format
note right: Must be valid HTTPS URL\nNo localhost or private IPs\nDomain must be resolvable

ValidationService -> HttpClient : POST {url}/webhook-test\n{challenge: "{random}"}
activate HttpClient
note right: Send verification challenge\nto confirm endpoint is active

alt Endpoint Unreachable or Invalid Response
    HttpClient --> ValidationService : Error or Invalid Response
    deactivate HttpClient
    ValidationService --> Handler : ValidationFailed\n{reason: "Endpoint verification failed"}
    Handler --> Mediator : ValidationException
    Mediator --> Controller : 400 Bad Request
    Controller --> Gateway : 400 Bad Request\n{error: "Webhook endpoint verification failed"}
    Gateway --> UI : Error
    UI --> Developer : Registration Failed\n"Unable to verify webhook endpoint"
else Endpoint Valid
    HttpClient --> ValidationService : 200 OK\n{challenge: "{random}"}
    deactivate HttpClient
    ValidationService --> Handler : Valid
    deactivate ValidationService

    Handler -> Handler : Check Webhook Limit
    note right: Verify account hasn't\nexceeded webhook limit

    alt Webhook Limit Exceeded
        Handler --> Mediator : ValidationException
        Mediator --> Controller : 400 Bad Request
        Controller --> Gateway : 400 Bad Request\n{error: "Webhook limit exceeded for account"}
        Gateway --> UI : Error
        UI --> Developer : Registration Failed
    else Within Limit
        Handler -> Handler : Webhook.Register()
        note right: Domain entity\nraises WebhookRegisteredDomainEvent

        Handler -> Repo : AddAsync(webhook)
        activate Repo
        Repo -> DB : INSERT Webhook
        activate DB
        DB --> Repo : Success
        deactivate DB
        Repo --> Handler : Success
        deactivate Repo

        Handler -> Repo : SaveChangesAsync()
        activate Repo
        Repo -> DB : COMMIT Transaction
        activate DB
        DB --> Repo : Success
        deactivate DB
        Repo --> Handler : Success
        deactivate Repo

        Handler -> EventDispatcher : DispatchAsync(domainEvents)
        activate EventDispatcher

        EventDispatcher -> ServiceBus : Publish\nWebhookRegisteredEvent
        activate ServiceBus
        note right: Integration event for:\n- Audit logging\n- Analytics\n- Monitoring setup
        ServiceBus --> EventDispatcher : Acknowledged
        deactivate ServiceBus

        EventDispatcher --> Handler : Complete
        deactivate EventDispatcher

        Handler --> Mediator : RegisterWebhookResponse\n{webhookId, status, createdAt}
        deactivate Handler

        Mediator --> Controller : Response
        deactivate Mediator

        Controller --> Gateway : 201 Created\n{webhookId, url, events, status}
        deactivate Controller

        Gateway --> UI : Response
        deactivate Gateway

        UI --> Developer : Webhook Registered Successfully!\nEvents: content.created, content.published
        deactivate UI
    end
end

@enduml

' ====================================================================
' Trigger & Deliver Webhook Flow
' ====================================================================
@startuml Trigger and Deliver Webhook
title Trigger & Deliver Webhook - Event Delivery with Retry Logic

participant "Domain Event Handler" as DomainHandler SERVICE_COLOR
participant "IWebhookRepository" as Repo REPOSITORY_COLOR
participant "DbContext" as DB DB_COLOR
participant "Azure Service Bus" as ServiceBus EVENT_COLOR
participant "Webhook Delivery Worker" as Worker EVENT_COLOR
participant "MediatR" as Mediator SERVICE_COLOR
participant "TriggerWebhookHandler" as Handler SERVICE_COLOR
participant "HttpClient" as HttpClient SERVICE_COLOR
participant "Webhook Endpoint" as WebhookEndpoint FRONTEND_COLOR
participant "Hangfire/Azure Functions" as BackgroundJob EVENT_COLOR
participant "IDomainEventDispatcher" as EventDispatcher EVENT_COLOR
participant "SignalR Hub" as SignalR EVENT_COLOR

note over DomainHandler: Event occurs (e.g., ContentCreatedDomainEvent)

DomainHandler -> DomainHandler : Handle Domain Event
activate DomainHandler

DomainHandler -> Repo : GetActiveWebhooksForEventAsync(accountId, "content.created")
activate Repo
Repo -> DB : SELECT Webhooks\nWHERE AccountId = {accountId}\nAND Status = Active\nAND Events CONTAINS "content.created"
activate DB
DB --> Repo : List<Webhook>
deactivate DB
Repo --> DomainHandler : List<Webhook>
deactivate Repo

loop For Each Webhook
    DomainHandler -> ServiceBus : Publish\nWebhookDeliveryMessage\n{webhookId, eventType, payload}
    activate ServiceBus
    note right: Queue message for\nasync processing
    ServiceBus --> DomainHandler : Acknowledged
    deactivate ServiceBus
end

deactivate DomainHandler

note over Worker: Background worker\nprocesses queue

ServiceBus -> Worker : WebhookDeliveryMessage
activate Worker

Worker -> Mediator : Send(TriggerWebhookCommand)
activate Mediator

Mediator -> Handler : Handle(TriggerWebhookCommand)
activate Handler

Handler -> Repo : GetByIdAsync(webhookId)
activate Repo
Repo -> DB : SELECT Webhook
activate DB
DB --> Repo : Webhook
deactivate DB
Repo --> Handler : Webhook
deactivate Repo

Handler -> Handler : Verify webhook active
note right: Check status and\nevent subscription

alt Webhook Inactive or Deleted
    Handler --> Mediator : TriggerWebhookResponse\n{success: false, reason: "Webhook inactive"}
    Mediator --> Worker : Failed
    Worker -> Worker : Log & Discard
    Worker --> ServiceBus : Message Complete
else Webhook Active
    Handler -> Handler : Build Webhook Payload
    note right: Format:\n{\n  "event": "content.created",\n  "timestamp": "...",\n  "data": {...}\n}

    Handler -> Handler : WebhookDelivery.CreateAttempt()
    note right: Create delivery record\nwith retry count

    Handler -> Repo : AddDeliveryAsync(webhookDelivery)
    activate Repo
    Repo -> DB : INSERT WebhookDelivery
    activate DB
    DB --> Repo : Success
    deactivate DB
    Repo --> Handler : Success
    deactivate Repo

    Handler -> Repo : SaveChangesAsync()
    activate Repo
    Repo -> DB : COMMIT
    activate DB
    DB --> Repo : Success
    deactivate DB
    Repo --> Handler : Success
    deactivate Repo

    Handler -> HttpClient : POST {webhook.url}\nBody: {payload}\nHeaders:\n- X-Webhook-Signature\n- X-Event-Type\n- X-Webhook-Id
    activate HttpClient
    note right: Include HMAC signature\nfor verification\nTimeout: 30 seconds

    alt Delivery Failed (Timeout, Network Error, 5xx)
        HttpClient --> Handler : Error or HTTP 5xx
        deactivate HttpClient

        Handler -> Handler : webhookDelivery.MarkFailure(reason)
        Handler -> Handler : webhook.RecordFailedDelivery(eventType, reason, retryCount)
        note right: Increment failure count\nDisable after 5 failures

        Handler -> Repo : UpdateAsync(webhook)
        activate Repo
        Repo -> DB : UPDATE Webhook\nSET FailureCount++
        activate DB
        DB --> Repo : Success
        deactivate DB
        Repo --> Handler : Success
        deactivate Repo

        Handler -> Repo : SaveChangesAsync()
        activate Repo
        Repo -> DB : COMMIT
        activate DB
        DB --> Repo : Success
        deactivate DB
        Repo --> Handler : Success
        deactivate Repo

        Handler -> EventDispatcher : DispatchAsync(domainEvents)
        activate EventDispatcher

        par Parallel Event Processing
            EventDispatcher -> ServiceBus : Publish\nWebhookFailedEvent
            activate ServiceBus
            note right: For monitoring and alerting
            ServiceBus --> EventDispatcher : Acknowledged
            deactivate ServiceBus
        and
            EventDispatcher -> SignalR : Notify Real-time\nWebhookFailed
            activate SignalR
            SignalR --> EventDispatcher : Acknowledged
            deactivate SignalR
        end

        EventDispatcher --> Handler : Complete
        deactivate EventDispatcher

        Handler -> Handler : Check Retry Count
        note right: Retry with exponential backoff:\n- Attempt 1: immediate\n- Attempt 2: 5 minutes\n- Attempt 3: 30 minutes\n- Attempt 4: 2 hours\n- Attempt 5: 12 hours

        alt Should Retry (retryCount < 5)
            Handler -> BackgroundJob : Schedule Retry\nDelay: {exponentialBackoff}
            activate BackgroundJob
            note right: Hangfire/Azure Functions\nschedules delayed retry
            BackgroundJob --> Handler : Job Scheduled
            deactivate BackgroundJob

            Handler --> Mediator : TriggerWebhookResponse\n{success: false, failureReason, willRetry: true}
        else Max Retries Exceeded
            Handler --> Mediator : TriggerWebhookResponse\n{success: false, failureReason, willRetry: false}
            note right: Webhook disabled\nafter 5 consecutive failures
        end

    else Delivery Successful (2xx)
        HttpClient --> Handler : HTTP 200/201/204\n{response}
        deactivate HttpClient

        Handler -> Handler : Measure Response Time
        Handler -> Handler : webhookDelivery.MarkSuccess(responseStatus, responseTime)
        Handler -> Handler : webhook.RecordSuccessfulDelivery(eventType, payload, responseStatus)
        note right: Reset failure count\nUpdate last triggered time

        Handler -> Repo : UpdateAsync(webhook)
        activate Repo
        Repo -> DB : UPDATE Webhook\nSET FailureCount = 0, LastTriggeredAt = NOW
        activate DB
        DB --> Repo : Success
        deactivate DB
        Repo --> Handler : Success
        deactivate Repo

        Handler -> Repo : SaveChangesAsync()
        activate Repo
        Repo -> DB : COMMIT
        activate DB
        DB --> Repo : Success
        deactivate DB
        Repo --> Handler : Success
        deactivate Repo

        Handler -> EventDispatcher : DispatchAsync(domainEvents)
        activate EventDispatcher

        par Parallel Event Processing
            EventDispatcher -> ServiceBus : Publish\nWebhookTriggeredEvent
            activate ServiceBus
            note right: For analytics and monitoring
            ServiceBus --> EventDispatcher : Acknowledged
            deactivate ServiceBus
        and
            EventDispatcher -> SignalR : Notify Real-time\nWebhookTriggered
            activate SignalR
            SignalR --> EventDispatcher : Acknowledged
            deactivate SignalR
        end

        EventDispatcher --> Handler : Complete
        deactivate EventDispatcher

        Handler --> Mediator : TriggerWebhookResponse\n{success: true, responseStatus}

    else Delivery Rejected (4xx Client Error)
        HttpClient --> Handler : HTTP 4xx
        deactivate HttpClient

        Handler -> Handler : webhookDelivery.MarkFailure("Client Error", responseStatus)
        note right: Don't retry on 4xx errors\n(except 429 Too Many Requests)

        Handler -> Repo : SaveChangesAsync()
        activate Repo
        Repo -> DB : COMMIT
        activate DB
        DB --> Repo : Success
        deactivate DB
        Repo --> Handler : Success
        deactivate Repo

        Handler --> Mediator : TriggerWebhookResponse\n{success: false, responseStatus, willRetry: false}
    end
end

deactivate Handler
Mediator --> Worker : Response
deactivate Mediator

Worker --> ServiceBus : Message Complete
deactivate Worker
deactivate ServiceBus

@enduml

@enduml
